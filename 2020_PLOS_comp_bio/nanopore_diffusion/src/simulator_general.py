"""Functions used by various simulators"""

#Standard library
from __future__ import print_function, division #Python 2 compatibility
from collections import OrderedDict
import importlib
import os
import os.path as osp
import sys
import types

#Site packages
import fenics as fem
import numpy as np

#Local
import folderstructure as FS
import common
import plotdata

#Path to this code file (for dependency list)
thisfile=sys.modules[__name__].__file__

def list_outputfiles(cmdlist):
  """Get a list of all the files generated by the data extraction commands.

  Arguments:

    - cmdlist = list of data extraction commands,
      each command consists of pair (cmdname, arguments):

        - cmdname = name of data extraction method of the simulator class
        - arguments = dictionary of all arguments needed by the extraction method

  Return:

    - outfiles = list of generated output files (names only, not including their folder)"""
  #Currently, we assume all files can only come from the 'filename' argument
  filearg_list=['filename']
  outfiles=[]
  for cmdname, arguments in cmdlist:
    #Check all possible arguments that could contain the name of an output file
    present_args=[n for n in filearg_list if n in arguments.keys()]
    outfiles.extend([arguments[n] for n in present_args])
  return outfiles

class GenericConditions(common.ParameterSet):
  """Condition defnitions, to be subclassed by each equation as needed

  Attributes:

    - elementorder = integer specifying equation order (1=1st, 2=2nd, etc) for finite elements"""
  __slots__=['elementorder']

class OutData(common.ParameterSet):
  """Data from simulator to be written to disk.

  Attributes:

    - plots = Dictionary of plot data, {plotname: [plotdata.PlotSeries, ...], ...}"""
  __slots__=['plots']

class SimulatorCustomizations(common.ParameterSet):
  """Information about custom methods and attributes for the simulator class

  Attributes:

    - modules = a sequence of modules to be imported. All functions defined inside become methods of the simulator.

      (Technically, all functions whose names appear in dir(module), which could be tailored by defining __dir__ if desired.)

    - initializations = a dictionary {module name: {variable: value}}

      Upon loading the module, the values in this dictionary will be passed as keyword arguments
        to the function `initialize_module`, if present, within the module.
      Modules listed here but not in `modules` are silently ignored.

    - extra = dictionary {additional simulator attributes: initial value}"""
  __slots__=['modules','initializations','extra']

class ModelParametersBase(common.ParameterSet):
  """Subclass of common.ParameterSet to store generic simulator parameters

  Note that this class does not have a 'run' method,
  because it doesn't have the simulator class to be used for the specified equation.
  It can't, because those modules need to import this one, and circular dependency is not allowed.
  See module 'simulator_run.py' for the derived class that has a 'run' method.

  Attributes:

    To be read in from file:

      - modelname = stem name for output files
      - meshname = stem name for mesh files
      - equation = name of equation to be solved
      - conditions = parameters specifying boundary conditions, initial conditions, property values, etc.

        The parameters specified are specific to the equation being solved.
        See the equation's module for the equation-specific conditions object,
        which will usually inherit from GenericConditions.

      - dataextraction = a sequence of data extraction commands to execute after solving the model

        Each command is a pair (cmdname, arguments), where:

          - cmdname = name of the simulator object's method to call, as a string
          - arguments = dictionary of arguments to the method: {argname: value,...}

      - datasteps = a sequence of data extraction commands to execute at each time step

        Note: Not all simulators will support this argument. It is mainly intended for time-domain equations.
        The command structure is the same as for dataextraction.

      - customizations = parameters specifying an instance of SimulatorCustomizations
      - loaddata = a sequence of data loading commands to execute at simulator initialization
      
        Each command is a triple (attrname, filepath, fieldtag), where:
        
          - attrname = the name of the simulator attribute, as a string, to store the loaded data
          - filepath = path to the data file to load, as string, relative to folderstructure.datafolder
          - fieldtag = string identifying the HDF5 field name to load
      
      - metadata = dictionary of metadata about the model, for use in post-processing

    To be calculated from methods:

      - outdir = folder containing output files
      - mesh_hdf5 = mesh input hdf5 file, as string
      - meshmetafile = mesh metadata file"""
  __slots__=('modelname','meshname','equation','conditions','dataextraction','datasteps','customizations','loaddata','metadata',
             'outdir','mesh_hdf5','meshmetafile','_more_inputfiles','_more_outputfiles')
  _required_attrs=['modelname','meshname','equation','conditions']
  _inputfile_attrs=['mesh_hdf5'] #don't need sourcefile as input file due to config
  _config_attrs=['basename']+_required_attrs+['dataextraction','datasteps']
  _taskname_src_attr='modelname'

  def __init__(self,**kwd):
    #Initialization from base class
    super(ModelParametersBase, self).__init__(**kwd)
    #Get output directory
    self.outdir=osp.join(FS.solnfolder,self.basename,self.modelname)
    #Get code file dependencies
    self._more_inputfiles=[thisfile, common.__file__]
    #Load customization info, if present
    if hasattr(self,'customizations'):
      self.customizations=SimulatorCustomizations(**self.customizations)
      for modname in getattr(self.customizations,'modules',[]):
        self._more_inputfiles.append(osp.join(FS.custom_modules_folder,modname+'.py'))
    #Get mesh HDF5 file
    self.mesh_hdf5=osp.join(FS.mesh_hdf5_folder,self.basename,self.meshname+'.hdf5')
    #Get mesh metadata file
    self.meshmetafile=osp.join(FS.meshmeta_outfolder,self.basename,self.meshname+'.yaml')
    self._more_inputfiles.append(self.meshmetafile)
    #Get input files from load data commands
    for aname,fpath,ftag in getattr(self,'loaddata',[]):
      self._more_inputfiles.append(osp.join(FS.datafolder,fpath))
    #Get output files
    outfiles=[FS.infofile]
    outfiles+=list_outputfiles(getattr(self,'dataextraction',[]))
    outfiles+=list_outputfiles(getattr(self,'datasteps',[]))
    self._more_outputfiles=[osp.join(self.outdir,f) for f in outfiles if f is not None]

class EquationTerm(object):
  """To keep track of additional information about each UFL form added up into the equation to solve.
  
  Attributes:
  
    - name = a string uniquely identifying the equation term
    - ulf = the UFL form object for the term"""

  def __init__(self,name,ufl,**kwargs):
    self.name=name
    self.ufl=ufl
    for k,v in kwargs.items():
      setattr(self,k,v)

class EquationTermDict(OrderedDict):
  """An ordered dictionary of equation terms.
  
  Attributes:
  
    - termclass = the class of which all equationterms are instances"""

  def __init__(self,termclass=EquationTerm,*args,**kwargs):
    #Initialization from base class
    super(EquationTermDict, self).__init__(*args,**kwargs)
    #Store the term class
    self.termclass=termclass

  def add(self,*args,**kwargs):
    """Create a new term and add it to this dictionary.
    
    Arguments are the same as those to create a new EquationTerm"""
    term=self.termclass(*args,**kwargs)
    self[term.name]=term

  def selectterms(self,**kwargs):
    """Return an EquationTermDict of terms with the specified properties"""
    out=EquationTermDict(self.termclass)
    for name,term in self.items():
      include=True
      for k,v in kwargs.items():
        if getattr(term,k)!=v:
          include=False
          break
      if include:
        out[name]=term
    return out

  def sumterms(self,zeroval=None,**kwargs):
    """Return the sum of terms with the specified properties, as a UFL form
    
    Arguments:
    
      - zeroval = optional, UFL form to be returned if no terms match the specified properties
      - **kwargs = keyword arguments for selectterms"""
    terms=self.selectterms(**kwargs)
    if len(terms)>0:
      return sum([t.ufl for t in terms.values()])
    elif zeroval is not None:
      return zeroval
    else:
      #zeroval was not provided
      raise RuntimeError("Unable to return a proper sum of zero terms; Provide keyword argument zeroval to resolve.")

class MeshInfo:
  """Bunch of mesh-related data

  Attributes:

    - mesh = FEniCS Mesh
    - facets = FEniCS MeshFunction of gmsh Physical Surface number (3D) or Physical Line number (2D)
    - cells = FEniCS MeshFunction of gmsh Physical Volume number (3D) or Physical Surface number (2D)
    - metadata = dictionary of metadata about the mesh, such as parametric locations

  A note on the terminology used in FEniCS and gmsh:

  |  The FEniCS information below is from page 185-186 of the FEniCS book.
  |  d = number of dimensions in entity,
  |  D = number of dimensions in problem (maximum entity dimension)
  |  D-d = "codimension" of entity
  |  Terms:
  |    D=2, d=1: fenics facet (facet_region xml) = fenics edge = gmsh physical line
  |    D=2, d=2: fenics cell (physical_region xml) = fenics face = gmsh physical surface
  |    D=3, d=2: fenics facet (facet_region xml) = fenics face = gmsh physical surface
  |    D=3, d=3: fenics cell (physical_region xml) = fenics ____ = gmsh physical volume
  |    also, d=0 is a fenics vertex"""

  def __init__(self,modelparams):
    "Load Mesh and MeshFunctions from HDF5 file, and mesh metadata from yaml"
    #Initialize empty objects
    self.mesh=fem.Mesh()
    self.facets=fem.MeshFunction("size_t", self.mesh)
    self.cells=fem.MeshFunction("size_t", self.mesh)
    #Read in data from HDF5 file
    hdf5=fem.HDF5File(self.mesh.mpi_comm(),modelparams.mesh_hdf5,'r')
    hdf5.read(self.mesh,'mesh',False)
    hdf5.read(self.facets,'facets')
    hdf5.read(self.cells,'cells')
    hdf5.close()
    #Load mesh metadata file
    assert osp.isfile(modelparams.meshmetafile), "Mesh metadata file does not exist: %s"%modelparams.meshmetafile
    self.metadata=common.readyaml(modelparams.meshmetafile)


class GenericSimulator(object):
  """A generic simulator, to be subclassed by simulators for the specific equations

  This class is not directly usable itself.
  Derived classes should, at a minimum:

    - override __init__ to set up the variational problem (it's ok to use super() to set up the mesh)
    - implement a "run" method to generate the solution
      and other data needed by their data extraction functions.

  Subclasses may choose to override the extraction functions provided here.

  Attributes:

    - modelparams = simulator_run.ModelParameters instance
    - meshinfo = instance of MeshInfo
    - diskwrite = boolean, True to write results to disk.
    - outdir = directory for output data
    - results = dictionary of results used in data extraction calculations
    - info = dictionary of input and output data, stored to infofile as defined in folderstructure
    - outdata = instance of OutData"""
  def __init__(self,modelparams):
    """Initialize the simulator by loading the Mesh and MeshFunctions.

    Arguments:

      - modelparams = simulator_run.ModelParameters instance"""
    #Store defining ParameterSet objects
    self.modelparams=modelparams

    #Initialize output attributes and intermediates
    self.diskwrite=True
    self.outdir=self.modelparams.outdir
    self.results={}
    self.info=self.modelparams.config_dict
    self.info.update(getattr(self.modelparams,'metadata',{}))
    self.outdata=OutData(plots={})
    
    #Load mesh
    self.meshinfo=MeshInfo(modelparams)
    
    #Apply customizations
    if hasattr(self.modelparams,'customizations'):
      loaded_modules={}
      module_initializations=getattr(self.modelparams.customizations,'initializations',{})
      #Bind methods
      for modname in getattr(self.modelparams.customizations,'modules',[]):
        #Load module
        themod=importlib.import_module(modname)
        loaded_modules[modname]=themod
        #Intialize, if requested
        if modname in module_initializations.keys():
          kwargs = module_initializations[modname]
          if (kwargs is not None) and hasattr(themod,'initialize_module'):
            themod.initialize_module(**kwargs)
        #Assign all module functions as simulator methods
        mod_contents=dict([(f,getattr(themod,f)) for f in dir(themod)])
        for nm, itm in mod_contents.items():
          if isinstance(itm,types.FunctionType):
            setattr(self,nm,types.MethodType(itm,self)) #Must type cast to MethodType in order to get implicit first argument `self`
      #Assign extra attributes
      for k,v in getattr(self.modelparams.customizations,'extra',{}).items():
        setattr(self,k,v)

  def loadfield(self,infpath,fieldtag,attrname,idx=None):
    """Load data into the simulator from an HDF5 input file
    
    Arguments:
    
      - infpath = path to input file, as string, relative to folderstructure.datafolder
      
      - fieldtag = string identifying the HDF5 field name to load
      
      - attrname = attribute name to load the data into, as string
      
        Note that this attribute must already exist, and be of the proper type to receive the requested data.
      
      - idx = index number (as integer) speciying location within the given attribute, None (default) if not the attribute itself is not a sequence
    
    No return value."""
    fullpath=osp.join(FS.datafolder,infpath)
    inputval = getattr(self,attrname)
    if idx is not None:
      inputval = inputval[idx]
    hdf5=fem.HDF5File(self.meshinfo.mesh.mpi_comm(),fullpath,'r')
    hdf5.read(inputval,fieldtag)
    hdf5.close()

  def process_load_commands(self,attrname='loaddata'):
    """Process a list of load data commands

    Arguments:

      - attrname = attribute name of self.modelparams containing the command list

    No return value."""
    for cmd in getattr(self.modelparams,attrname,[]):
      #Function arguments
      aname, fpath, ftag = cmd
      #Call it
      try:
        self.loadfield(fpath,ftag,aname)
      except Exception as einst:
        print("Exception occured in %s for command: %s"%(attrname,str(cmd)), file=sys.stderr)
        raise einst
    return

  @classmethod
  def complete(cls,*args):
    """Convenience function to set up and solve the model, then generate all the requested output.

    Arguments:

      - \*args to be passed to the the simulator class __init__"""
    obj=cls(*args)
    obj.run()
    obj.create_output()
    return obj

  def run(self):
    "Method to be overridden by derived classes"
    raise NotImplementedError("%s did not override 'run' method."%str(type(self)))

  def convert_input_value(self,arg,element,expclass=fem.Expression,classargs=None):
    """Convert the input value into an appropriate FEniCS object: Constant or Expression.

    If the argument is an integer or float, a Constant is returned.
    Otherwise, the argument must be a list or tuple, with length 2:

      (exprstr, exprargs), where:

        - exprstr = expression string or tuple (see FEniCS Expression documentation)
        - exprargs = dictionary of keyword arguments to FEniCS Expression, the user_parameters

    Arguments:

      - arg = input value to process
      - element = FEniCS FiniteElement to use for Expression
      - expclass = optional, subclass of Expression to use instead
      - classargs = optional, sequence of positional arguments to provide to constructor of Expression subclass

    Returns:

      - out = converted object

    Attributes (created if necessary):

      - all_expressions = dictionary of created expressions: {expression: arguments}
      - all_expr_args = dictionary containing all expression arguments: {argument: value}

    These attributes are used by update_expressions."""
    if type(arg)==int or type(arg)==float:
      out = fem.Constant(arg)
    elif type(arg)==list or type(arg)==tuple:
      assert len(arg)==2, "Invalid sequence for conversion to expression: %s"%arg
      exprstr, exprargs = value
      classargs = [] if classargs is None else classargs
      out = expclass(exprstr, *classargs, element=element, **exprargs)
      #Argument tracking for later updates
      if not hasattr(self, 'all_expressions'):
        self.all_expressions={}
      self.all_expressions[out]=tuple(exprargs.keys())
      if not hasattr(self, 'all_expr_args'):
        self.all_expr_args={}
      self.all_expr_args.update(exprargs)
    else:
      raise Exception("Cannot process input value %s"%arg)
    return out

  def update_expressions(self):
    """Update expressions created with convert_input_value"""
    for expr,argnames in self.all_expressions.items():
      current=dict([(k,self.all_expr_args[k]) for k in argnames])
      expr.user_parameters.update(current)

  def process_output_commands(self,attrname='dataextraction'):
    """Process a list of data extraction commands

    Arguments:

      - attrname = attribute name of self.modelparams containing the command list

    No return value."""
    for cmd in getattr(self.modelparams,attrname,[]):
      #Function name and arguments
      funcname, kwargs = cmd
      #Call it
      try:
        getattr(self,funcname)(**kwargs)
      except Exception as einst:
        print("Exception occured in %s for command: %s"%(attrname,str(cmd)), file=sys.stderr)
        raise einst
    return

  def create_output(self):
    """Process the data extraction commands for the completed solution

    Required attributes:

      - diskwrite = boolean, True to write the output files.

        If false, the output will only be stored in the object itself

    No return value.

    Output files may be generated."""
    #Output location(s)
    if not osp.isdir(self.outdir):
      os.makedirs(self.outdir)

    #Process each command
    self.process_output_commands('dataextraction')

    #Put results into info
    self.info['results']=self.results
    #Add mesh metadata
    self.info['mesh_metadata']=self.meshinfo.metadata
    #Write output files if requested
    if self.diskwrite:
      common.writeyaml(self.info,osp.join(self.outdir,FS.infofile))
      self.outdata.to_pickle(osp.join(self.outdir,'outdata.pkl'))

    #Done
    return

  def solutionfield(self,filename,attrname='soln',idx=None,outname=None):
    """Write solution field to VTK file

    Arguments:

      - filename = name of output file, as string

        File will be created in the output directory (self.outdir).
        If the filename ends with ".hdf5" (case insensitive), an HDF5 file is created.
        Otherwise, the filetype is selected by FEniCS.

      - attrname = name of attribute to output, as string, defaults to 'soln'
      
      - idx = index number (as integer) of the solution field to write out, None (default) if not a sequence
      
      - outname = optional output field name within output file, as string, supported only for HDF5 format.
      
        If not provided, output field name defaults to value calculated from attrname and idx.

    Required attributes:

      - outdir = output directory, as string
      - soln = FEniCS Function containing solution

    No new attributes.

    No return value.

    Output file is written."""
    output = getattr(self,attrname)
    if idx is not None:
      output = output[idx]
    outfpath=osp.join(self.outdir,filename)
    if osp.splitext(filename)[1].lower()=='.hdf5':
      #HDF5 format
      if outname is None:
        fieldtag=attrname
        if idx is not None:
          fieldtag+='_%d'%idx
      else:
        fieldtag = outname
      hdf5=fem.HDF5File(self.meshinfo.mesh.mpi_comm(),outfpath,'w')
      hdf5.write(output,fieldtag)
      hdf5.close()
    else:
      #Format controlled by FEniCS (including VTK files: .pvd, etc.)
      out_file=fem.File(outfpath)
      out_file << output
    return

  def splitfield(self,namewhole,namesplit):
    """Call the split() method of a solution field.

    Arguments:

      - namewhole = name of the field to split
      - namesplit = attribute name to store the result in

    Required attributes:

      - The attribute specified by namewhole.

    New attributes:

      - The attribute specified by namesplit.

    No return value.

    No other side-effects."""
    setattr(self,namesplit,getattr(self,namewhole).split())

  def facet_area(self,pfacet,name,internal=False):
    """Compute the area of the specified facet.

    Arguments:

      - pfacet = physical facet number of facet to calculate area of
      - name = name for storage in the results dictionary
      - internal = boolean, default False, True for internal boundary, False for external

    Required attributes:

      - mesh = FEniCS Mesh object
      - facet = FEniCS MeshFunction object for facet numbers

    No new attributes.

    New item(s) added to results dictionary.

    No return value."""
    if internal:
      integral_type='interior_facet'
    else:
      integral_type='exterior_facet'
    this_ds=fem.Measure(integral_type,domain=self.meshinfo.mesh,subdomain_data=self.meshinfo.facets)
    calcarea=fem.assemble(fem.Constant(1)*this_ds(pfacet))
    self.results[name]=calcarea
    return

  def get_pointcoords(self,location):
    """Process a location specifier.

    Arguments:

      - location = specifier of location within the mesh

        This should be a tuple, with length matching the problem dimensions.
        Each entry is either a number or a string.
        Numbers represent physical coordinates within the mesh.
        Strings are replaced with the corresponding entry from the mesh metadata dictionary.
          (which is a required attributed in that case)

    Required attributes:

      - mesh_metadata = only required if needed by location specifiers, dictionary of mesh metadata

    Returns:

      - coords = the converted tuple"""
    coords=tuple()
    for v in location:
      if type(v)==str:
        v=self.meshinfo.metadata[v]
      coords+=(v,)
    return coords

  def line_profile(self,startloc,endloc,num,plotname,label,attrname='soln',indep=None,idx=None):
    """Get data to plot a result along the specified line at a single point in time

    Arguments:

      - startloc = argument to get_pointcoords for start of line
      - endloc = argument to get_pointcoords for end of line
      - num = number of sampled points
      - indep = index of the coordinate parameter to use as the independent variable for the plot (zero-based) (omit to use distance from start point)
      - plotname = name of plot in outdata.plots, as string
      - label = series label to assign, as string
      - attrname = name of attribute to output, as string, defaults to 'soln'
      - indep = identifier for independent variable:
          integer 0-d to use that coordinate of the point, or
          None (default) to use distance from the start point
      - idx = index of the solution field to write out, None (default) if not a sequence

    Required attributes:

      - outdata = instance of OutData
      - mesh_metadata = only required if needed by location specifiers, dictionary of mesh metadata

    No new attributes.

    Nothing added to results dictionary.

    No return value.

    Series is added to ``outdata.plots``."""
    #Get the object with the data
    vals=getattr(self,attrname)
    if idx is not None:
      vals = vals[idx]
    #Get the points for data extraction
    assert len(startloc)==len(endloc), "Start and end locations have different dimensionality"
    startcoords=self.get_pointcoords(startloc)
    endcoords=self.get_pointcoords(endloc)
    start_ends=[itm for itm in zip(startcoords,endcoords)]
    ranges=[np.linspace(start,end,num) for start,end in start_ends]
    points=[t for t in zip(*ranges)]
    #Function to calculate independent variable for a given point
    if indep is None:
      indep_f = lambda pt: np.sqrt(sum([(startcoords[i]-c)**2 for i,c in enumerate(pt)]))
    else:
      indep_f = lambda pt: pt[indep]
    #Extract data points
    llist=[]
    vlist=[]
    for pt in points:
      try:
        vlist.append(vals(*pt))
        llist.append(indep_f(pt))
      except RuntimeError:
        pass #point is not inside mesh; skip
    #Create PlotSeries
    larr=np.array(llist)
    varr=np.array(vlist)
    series=plotdata.PlotSeries(xvals=larr,yvals=varr,label=label)
    #Store data
    if not plotname in self.outdata.plots.keys():
      self.outdata.plots[plotname]=[]
    self.outdata.plots[plotname].append(series)
    return
